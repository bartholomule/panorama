/*
*  Copyright (C) 2003 Kevin Harris
*
*  This program is free software; you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation; either version 2 of the License, or
*  (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful, but
*  WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with this program; if not, write to the Free Software
*  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*
*  As a special exception, source code generated by this program is not
*  neccessarily automatically covered by the GPL.  You are free to change the
*  text below, so that it will generate code with the license of your choice,
*  providing all copyright and license information for this program remains
*  intact.
*/



#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <time.h>
#include <cstdio>
using namespace std;

// Put your name here...
static const string AuthorName = "Kevin Harris";
// Put your email address here...
static const string EmailText = "kpharris@users.sourceforge.net";
// Change the package description as required.
static const string PackageText = "Part of GNU Panorama - A framework for 3D graphics production";
static const string HeaderExtension = "h";


string GenerateFileHeader()
{
  static const string CVS_HEADER = string("$") + "Header$";


  time_t current_time;
  time(&current_time);
  tm* time_struct = localtime(&current_time);
  char year_text[6];
  sprintf(year_text, "%d", (time_struct->tm_year) + 1900);
  
  
  string header = (string("/*\n") + 
		   " * " + CVS_HEADER + "\n *\n" +
		   " * " +PackageText + "\n" +
		   " * Copyright (C) " + year_text + " " + AuthorName + "\n" +
                   " *\n\
 * This program is free software; you can redistribute it and/or modify \n\
 * it under the terms of the GNU General Public License as published by \n\
 * the Free Software Foundation; either version 2 of the License, or    \n\
 * (at your option) any later version.                                  \n\
 *                                                                      \n\
 * This program is distributed in the hope that it will be useful, but  \n\
 * WITHOUT ANY WARRANTY; without even the implied warranty of           \n\
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    \n\
 * General Public License for more details.                             \n\
 * *  You should have received a copy of the GNU General Public License \n\
 * along with this program; if not, write to the Free Software          \n\
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.\n\
 */");

  return header;
}

string GenerateClassDeclaration(const string& classname,
				const string& indent = string(""),
				const string& parentname = string(""))
{
  string declaration;


  declaration += "// BEGIN(DELETEME)\n";
declaration += "//-----------------------------------------------------------\n";
  declaration += "#error You must customize this automatically generated class.\n";
  declaration += "// To do this, you must: \n";
  string last_num_used = "1";
  if( !parentname.empty() )
  {
    declaration += ("// (" + last_num_used + ") " +
		    "Provide the proper include for class " + parentname +
		    " (above).\n");
    ++last_num_used[0];
  }
  declaration += ("// (" + last_num_used + ") " + 
		  "Enter a class description below, on the line requested.\n");
  ++last_num_used[0];
  
  declaration += ("// (" + last_num_used + ") " +
		  "Add your own class members to the class.\n");
  ++last_num_used[0];
  
  declaration += ("// (" + last_num_used + ") " +
                  "Provide the required operations in the copy constructor and assignment\n//  operator (in the corresponding .cpp file).\n");
  ++last_num_used[0];
  
  
  
  declaration += "//-----------------------------------------------------------\n";
  declaration += "// END(DELETEME)\n\n";  
 
  declaration += indent + "/**\n";
  declaration += indent + " * \n";
  declaration += indent + " * ***CLASS DESCRIPTION GOES HERE*** (multiple lines are ok)\n";
  declaration += indent + " * \n";    
  declaration += indent + " * @author " + AuthorName + " <" + EmailText + ">\n";
  declaration += indent + " * @version $" + "Revision: 1.1 $\n";
  declaration += indent + " * \n";
  declaration += indent + " */\n";
  
  declaration += indent + "class " + classname;
  if( !parentname.empty() )
  {
    declaration += " : public " + parentname;
  }
  declaration += "\n";
  declaration += indent + "{\n";
  declaration += "\n";
  declaration += indent + "private:\n";
  declaration += "\n";
  declaration += indent + "protected:\n";
  declaration += "\n";
  declaration += indent + "public:\n";
  declaration += indent + "  /**@name Functions required for existance of a class */\n";
  declaration += indent + "  //@{\n";  
  declaration += indent + "  /// Default constructor\n";
  declaration += indent + "  " + classname + "();\n";
  declaration += "\n";
  declaration += indent + "  /// Destructor\n";
  declaration += indent + "  virtual ~" + classname + "();\n";
  declaration += "\n";
  declaration += indent + "  /// Copy constructor\n";
  declaration += indent + "  " + classname + "(const " + classname + "& old);\n";
  declaration += "\n";
  declaration += indent + "  /// Assignment operator\n";
  declaration += indent + "  " + classname + "& operator= (const " + classname + "& old);\n";
  declaration += indent + "  //@}\n";  
  declaration += "\n";
  declaration += indent + "}; // class " + classname + "\n";
  return declaration;
} // GenerateClassDeclaration()


string GenerateClassDefinition(const string& classname,
			       const string& indent = string(""),
			       const string& parentname = string(""))
{
  string definition;
  string dash_name = string(classname.size(), '-');

  definition += indent + "//-------------------------------" + dash_name + "\n";
  definition += indent + "// Default constructor for class " + classname + "\n";
  definition += indent + "//-------------------------------" + dash_name + "\n";  
  
  definition += indent + classname + "::" + classname + "()";
  if( !parentname.empty() )
  {
    definition += ":\n";
    definition += indent + "  " + parentname + "()";
  }
  definition += "\n";
  definition += indent + "  // Class initializers go here. DELETEME\n";  
  definition += indent + "{\n";
  definition += indent + "\n";
  definition += indent + "} // " + classname + "()\n";    

  definition += "\n";

  definition += indent + "//----------------------" + dash_name + "\n";  
  definition += indent + "// Destructor for class " + classname + "\n";
  definition += indent + "//----------------------" + dash_name + "\n";  
  definition += indent + classname + "::~" + classname + "()\n";
  definition += indent + "{\n";
  definition += indent + "\n";
  definition += indent + "} // ~" + classname + "()\n";

  definition += "\n";
  
  definition += indent + "//----------------------------" + dash_name + "\n";  
  definition += indent + "// Copy constructor for class " + classname + "\n";
  definition += indent + "//----------------------------" + dash_name + "\n";  
  definition += indent + classname + "::" + classname + "(const " + classname
    + "& old)";
  if( !parentname.empty() )
  {
    definition += ":\n";
    definition += indent + "  " + parentname + "(old)";
  }
  definition += "\n";
  definition += indent + "  // Class initializers go here. DELETEME\n";  
  definition += indent + "{\n";
  definition += indent + "  // Insert any copy-assignment here. DELETEME\n";
  definition += indent + "} // " + classname + "(" + classname + ")\n";


  definition += "\n";  
  definition += indent + "//-------------------------------" + dash_name + "\n";  
  definition += indent + "// Assignment operator for class " + classname + "\n";
  definition += indent + "//-------------------------------" + dash_name + "\n";  
  
  definition += indent + classname + "& " + classname + "::operator= (const " +
    classname + "& old)\n";
  definition += indent + "{\n";
  definition += indent + "  // Generic check for self-assignment\n";  
  definition += indent + "  if( &old != this)\n";
  definition += indent + "  {\n";
  definition += indent + "    // Insert assignment here. DELETEME\n";
  definition += "\n";        
  if( !parentname.empty() )
  {
    definition += indent + "    " + parentname + "::operator=(old);\n";
  }
  definition += indent + "  }\n";
  definition += indent + "  return (*this);\n";
  
  definition += indent + "} // " + classname + "::operator=(" + classname + ")\n";  

  return definition;
} // GenerateClassDefinition()


#include <unistd.h>
#define _GNU_SOURCE
#include <getopt.h>

void RemoveSwitches(int& argc, char** argv, string& munged_class, string& parent, string& file_base)
{
  static struct option long_options[] = { {"output", 1, 0, 'o'},
					  {"parent", 1, 0, 'p'},
					  {"help", 0, 0, 'h'},
					  {"version", 0, 0, 'v'},
					  {0, 0, 0, 0} };

  int c;
  while ( 1 )
  {
    int count_to_remove = 0;
    int option_index = 0;
    c = getopt_long (argc, argv, "o:p:", long_options, &option_index);

    // If there aren't any options left... bail.
    if( c == -1 )
      break;

    switch(c)
    {
    case 'o':
      {
	file_base = string(optarg);
	count_to_remove = 2;
      }	break;
    case 'p':
      {
	parent = string(optarg);
	count_to_remove = 2;
      } break;
    case 'v':
      {
	cout << "Class Stub Generator version $Revision: 1.1.2.1 $" << endl;
	cout << "Copyright (C) 2003 Kevin Harris" << endl;
	cout << endl;
	cout << "This is free software, released under terms of the GNU Public License (GPL)" << endl;
	cout << "version 2 or later (at your option). See http://www.gnu.org/licenses/gpl.txt " << endl;
	exit(1);
      }
    case 'h':
      {
	cout << "Class Stub Generator version $Revision: 1.1.2.1 $" << endl;
	cout << "  This is a program to generate class stubs. \n\
  As arguments, it accepts one non-switch argument, which is the classname.\n\
  ie. giving it 'foo.baz' would generate a class baz in namespace foo.\n\
\n\
  The other options are:\n\
  -o --output - specifies the root of the otput filename (no extension)\n\
  -p --parent - specifies a class from which to publicly derive.\n\
\n\
  --version   - displays the version number and copyright/license \n\
  --help      - displays this help" << endl;
	exit(1);
      }
    default:
      {
      } break;
    }

    // Shift the rest of the args down, and remove the current one.
    for(int i = optind - count_to_remove; i < argc - count_to_remove; ++i)
    {
      argv[i] = argv[i+2];
    }
    optind -= count_to_remove;
    argc -= count_to_remove;

  }

  if( argc > 1 )
  {
    munged_class = string(argv[1]);
  }
}

void ExtractNamespaces(string& munged_name, vector<string>& namespaces)
{
  string temp;
  size_t last_location = 0;

  namespaces.erase(namespaces.begin(), namespaces.end());
  
  while(last_location < munged_name.size())
  {
    size_t new_location = munged_name.find('.', last_location);
    temp = munged_name.substr(last_location, new_location - last_location);
    namespaces.push_back(temp);
    last_location = new_location;
    if( last_location < munged_name.size() )
    {
      ++last_location;
    }
  }
  if( !namespaces.empty() )
  {
    munged_name = namespaces[namespaces.size() - 1];
    namespaces.pop_back();
  }
}

string GenerateNamespaceBegin(const vector<string>& namespaces, string& indent)
{
  string result;
  indent = string("");

  for(vector<string>::const_iterator i = namespaces.begin(); i != namespaces.end(); ++i)
  {
    result += (indent + "namespace " + *i + "\n" + 
	       indent + "{ \n");
    indent += "  ";
  }
  return result;
}

string GenerateNamespaceEnd(const vector<string>& namespaces, string& indent)
{
  string result;
  //  string indent = string(' ', namespaces.size() * 2);

  
  if( !namespaces.empty() )
  {
    indent = indent.substr(0, (namespaces.size() - 1) * 2);
  }

  
  for(vector<string>::const_reverse_iterator i = namespaces.rbegin(); i != namespaces.rend(); ++i)
  {
    result += indent + "} // namespace " + *i + "\n";
    indent = indent.substr(0, indent.size() - 2);
  }
  return result;
}

string IncludeGuardMunger(string s)
{
  for(unsigned i = 0; i < s.size(); ++i)
  {
    if( s[i] >= 'a' && s[i] <= 'z')
    {
      s[i] -= 'a' - 'A';
    }
    else if( s[i] == ' ' )
    {
      s[i] = '_';
    }
  }
  return s;
}


string GenerateIncludeGuardText(const vector<string>& namespaces, const string& output_root)
{
  string s = "__";
  for( int i = 0; i < (int(namespaces.size()) - 1); ++i)
  {
    s += namespaces[i] + "  ";
  }
  s += output_root + " " + HeaderExtension + "  ";
  return IncludeGuardMunger(s);
}

int main(int argc, char** argv)
{
  string classname = "UNNAMED";
  string parent = ""; 
  string output_root = "CLASSOUT";
  string indent;
  vector<string> namespaces;

  RemoveSwitches(argc, argv, classname, parent, output_root);

  if( classname == "UNNAMED" )
  {
    cerr << "Error: No class name supplied." << endl;
    exit(1);
  }

  ExtractNamespaces(classname, namespaces);

  if( output_root == "CLASSOUT" )
  {
    output_root = classname;
  }

  string namespace_guard_string = GenerateIncludeGuardText(namespaces, output_root);
  
  ofstream header_output(string(output_root + "." + HeaderExtension).c_str());

  if( !header_output )
  {
    cerr << "Error: Could not open \"" << output_root + "." + HeaderExtension << "\"" << endl;
    exit(1);
  }
  ofstream cpp_output(string(output_root + ".cpp").c_str());  
  if( !cpp_output )
  {
    cerr << "Error: Could not open \"" << output_root + ".cpp\"" << endl;
    exit(1);
  }  
  
  header_output << GenerateFileHeader() << endl;
  header_output << endl;
  header_output << "#if       !defined(" << namespace_guard_string << ")" << endl;
  header_output << "#define            " << namespace_guard_string << endl;
  header_output << endl;
  
  if( !parent.empty() )
  {
    header_output <<  "// --------------------------------------" << endl;
    header_output <<  "// Default include of parent class header" << endl;
    header_output <<  "// --------------------------------------" << endl;
    header_output <<  "#include \"" << parent << "." << HeaderExtension << "\"" << endl;
    header_output << endl;
  }
  header_output << GenerateNamespaceBegin(namespaces, indent) << endl;
  header_output << GenerateClassDeclaration(classname, indent, parent) << endl;
  header_output << GenerateNamespaceEnd(namespaces, indent) << endl;  
  header_output << endl;
  header_output << "#endif /* !defined(" << namespace_guard_string << ") */" << endl;  
  header_output << endl;


  
  cpp_output << GenerateFileHeader() << endl;
  cpp_output << endl;
  cpp_output << "#include \"" << output_root << "." << HeaderExtension << "\"" << endl;
  cpp_output << endl;
  cpp_output << endl;
  cpp_output << GenerateNamespaceBegin(namespaces, indent) << endl;
  cpp_output << GenerateClassDefinition(classname, indent, parent) << endl;    
  cpp_output << GenerateNamespaceEnd(namespaces, indent) << endl;

  header_output.close();
  cpp_output.close();
}
